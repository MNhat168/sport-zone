# GitHub Copilot Instructions for SportZone Project

## üéØ **Context**
You are working on SportZone - a sports facility booking platform built with NestJS, MongoDB, and TypeScript following modular architecture patterns.

## üèóÔ∏è **Architecture Guidelines**

### Follow NestJS Modular Architecture
- **Controller**: Handle HTTP requests, use guards, validation pipes
- **Service**: Business logic, data manipulation, error handling  
- **Repository**: Data access with MongoDB via Mongoose
- **Module**: Group related components, manage dependencies

### Always Use Repository Pattern
```typescript
// ‚úÖ Repository Interface
export interface UserRepositoryInterface {
    findAll(): Promise<User[]>;
    findById(id: string): Promise<User | null>;
    create(data: Partial<User>): Promise<User>;
    update(id: string, data: Partial<User>): Promise<User | null>;
    delete(id: string): Promise<User | null>;
}

// ‚úÖ Repository Implementation
@Injectable()
export class UserRepository implements UserRepositoryInterface {
    constructor(@InjectModel(User.name) private userModel: Model<UserDocument>) {}
    
    async findById(id: string): Promise<User | null> {
        return this.userModel.findById(id).exec();
    }
}
```

## üìù **Code Generation Rules**

### 1. Controller Methods
- Always include JSDoc documentation with examples
- Use Swagger decorators for API documentation
- Minimal logic - delegate to services
- Include authentication guards and validation pipes

```typescript
/**
 * L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo ID
 * @param id - ID c·ªßa ng∆∞·ªùi d√πng
 * @returns Th√¥ng tin chi ti·∫øt ng∆∞·ªùi d√πng
 */
@Controller('users')
@ApiTags('Users')
@UseGuards(JwtAccessTokenGuard)
export class UsersController {
    constructor(private readonly usersService: UsersService) {}

    @Get(':id')
    @ApiOperation({ summary: 'L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo ID' })
    @ApiParam({ name: 'id', description: 'User ID', example: '507f1f77bcf86cd799439011' })
    @ApiResponse({ status: 200, description: 'Th√†nh c√¥ng', type: User })
    @ApiResponse({ status: 404, description: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng' })
    async getUser(@Param('id') id: string): Promise<User> {
        return await this.usersService.findById(id);
    }
}
```

### 2. Service Methods
- Always async with proper error handling
- Use NestJS built-in exceptions
- Include business logic validation
- Use dependency injection with repository pattern

```typescript
@Injectable()
export class UsersService {
    private readonly logger = new Logger(UsersService.name);

    constructor(
        @Inject(USER_REPOSITORY) 
        private readonly userRepository: UserRepositoryInterface
    ) {}

    async getUsers(filter?: UserFilterDto): Promise<User[]> {
        try {
            let condition: FilterQuery<User> = { isActive: true };
            
            if (filter?.name) {
                condition.fullName = { $regex: filter.name, $options: 'i' };
            }
            
            if (filter?.role) {
                condition.role = filter.role;
            }
            
            const users = await this.userRepository.findByCondition(condition);
            this.logger.log(`Retrieved ${users.length} users`);
            
            return users;
        } catch (error) {
            this.logger.error('Error getting users', error);
            throw new InternalServerErrorException('Failed to retrieve users');
        }
    }

    async findById(id: string): Promise<User> {
        const user = await this.userRepository.findById(id);
        if (!user) {
            throw new NotFoundException(`User with ID ${id} not found`);
        }
        return user;
    }
}
```

### 3. DTOs/Models with Documentation
```typescript
import { IsString, IsEmail, IsEnum, IsOptional, Length } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { UserRole } from '@common/enums/user-role.enum';

/**
 * DTO cho vi·ªác t·∫°o ng∆∞·ªùi d√πng m·ªõi
 */
export class CreateUserDto {
    /**
     * Email c·ªßa ng∆∞·ªùi d√πng
     * @example "john.doe@example.com"
     */
    @ApiProperty({ 
        example: 'john.doe@example.com',
        description: 'Email c·ªßa ng∆∞·ªùi d√πng'
    })
    @IsEmail()
    email: string;
    
    /**
     * T√™n ƒë·∫ßy ƒë·ªß c·ªßa ng∆∞·ªùi d√πng
     * @example "John Doe"
     */
    @ApiProperty({ 
        example: 'John Doe',
        description: 'T√™n ƒë·∫ßy ƒë·ªß c·ªßa ng∆∞·ªùi d√πng'
    })
    @IsString()
    @Length(2, 50)
    fullName: string;
    
    /**
     * Vai tr√≤ c·ªßa ng∆∞·ªùi d√πng
     * @example "user"
     */
    @ApiPropertyOptional({ 
        enum: UserRole,
        example: UserRole.USER,
        description: 'Vai tr√≤ c·ªßa ng∆∞·ªùi d√πng'
    })
    @IsOptional()
    @IsEnum(UserRole)
    role?: UserRole;
}

/**
 * DTO cho vi·ªác l·ªçc danh s√°ch ng∆∞·ªùi d√πng
 */
export class UserFilterDto {
    @ApiPropertyOptional({ description: 'T√™n ƒë·ªÉ t√¨m ki·∫øm' })
    @IsOptional()
    @IsString()
    name?: string;

    @ApiPropertyOptional({ enum: UserRole })
    @IsOptional()
    @IsEnum(UserRole)
    role?: UserRole;
}
```

## üîß **Naming Conventions**

- Controllers: `{Entity}Controller` (e.g., `UsersController`, `FieldsController`)
- Services: `{Entity}Service` (e.g., `UsersService`, `BookingsService`)
- Repositories: `{Entity}Repository` (e.g., `UserRepository`, `FieldRepository`)
- Interfaces: `{Entity}RepositoryInterface` (e.g., `UserRepositoryInterface`)
- DTOs: 
  - Create: `Create{Entity}Dto` (e.g., `CreateUserDto`)
  - Update: `Update{Entity}Dto` (e.g., `UpdateUserDto`)
  - Filter: `{Entity}FilterDto` (e.g., `UserFilterDto`)
  - Response: `{Entity}ResponseDto` (optional, when different from entity)
- Entities: `{Entity}` (e.g., `User`, `Field`, `Booking`)
- Enums: `{Entity}Enum` (e.g., `UserRole`, `SportType`)
- Methods: `{action}{Entity}` for services (e.g., `createUser`, `findBookings`)
- Routes: `/{entity-name}` (kebab-case, e.g., `/users`, `/sport-fields`)

## üìä **Database Access Patterns**

```typescript
// ‚úÖ Efficient queries with populate and projection
const bookings = await this.bookingModel
    .find({ 
        userId: new Types.ObjectId(userId),
        status: BookingStatus.CONFIRMED 
    })
    .populate('field', 'name address hourlyRate')
    .populate('user', 'fullName email')
    .select('startTime endTime totalPrice status createdAt')
    .sort({ createdAt: -1 })
    .exec();

// ‚úÖ Aggregation pipeline for complex queries
const fieldStats = await this.fieldModel.aggregate([
    { $match: { isActive: true } },
    { $lookup: {
        from: 'bookings',
        localField: '_id',
        foreignField: 'field',
        as: 'bookings'
    }},
    { $addFields: {
        totalBookings: { $size: '$bookings' },
        revenue: { $sum: '$bookings.totalPrice' }
    }},
    { $project: {
        name: 1,
        address: 1,
        totalBookings: 1,
        revenue: 1
    }},
    { $sort: { revenue: -1 } }
]);

// ‚úÖ Pagination for list endpoints
const skip = (page - 1) * limit;
const [users, total] = await Promise.all([
    this.userModel
        .find(filterConditions)
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 })
        .exec(),
    this.userModel.countDocuments(filterConditions)
]);

return {
    data: users,
    pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
    }
};
```

## üö´ **Don't Generate**

- Direct MongoDB queries in controllers
- Generic `any` or `object` return types
- Methods without error handling
- APIs without authentication guards
- Code without JSDoc documentation
- Synchronous I/O operations
- Try-catch blocks in controllers (use global exception filters)
- Services without dependency injection
- DTOs without validation decorators
- Entities without proper Mongoose schemas

## ‚úÖ **Always Include**

- Proper exception handling with NestJS exceptions
- Authentication guards (`@UseGuards(JwtAccessTokenGuard)`)
- Validation pipes with DTOs (`@Body() dto: CreateUserDto`)
- JSDoc documentation with examples
- Swagger decorators (`@ApiOperation`, `@ApiResponse`)
- Async/await for I/O operations
- Dependency injection in constructors
- Repository pattern for data access
- Proper TypeScript typing

## üîç **Testing Patterns**

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';
import { NotFoundException } from '@nestjs/common';

describe('UsersService', () => {
    let service: UsersService;
    let mockRepository: jest.Mocked<UserRepositoryInterface>;

    beforeEach(async () => {
        const mockRepo = {
            findById: jest.fn(),
            findByCondition: jest.fn(),
            create: jest.fn(),
            update: jest.fn(),
            delete: jest.fn(),
        };

        const module: TestingModule = await Test.createTestingModule({
            providers: [
                UsersService,
                {
                    provide: USER_REPOSITORY,
                    useValue: mockRepo,
                },
            ],
        }).compile();

        service = module.get<UsersService>(UsersService);
        mockRepository = module.get(USER_REPOSITORY);
    });

    describe('findById', () => {
        it('should return user when found', async () => {
            // Arrange
            const userId = '507f1f77bcf86cd799439011';
            const mockUser = { 
                _id: userId, 
                fullName: 'John Doe', 
                email: 'john@example.com' 
            } as User;
            
            mockRepository.findById.mockResolvedValue(mockUser);

            // Act
            const result = await service.findById(userId);

            // Assert
            expect(result).toEqual(mockUser);
            expect(mockRepository.findById).toHaveBeenCalledWith(userId);
        });

        it('should throw NotFoundException when user not found', async () => {
            // Arrange
            const userId = '507f1f77bcf86cd799439011';
            mockRepository.findById.mockResolvedValue(null);

            // Act & Assert
            await expect(service.findById(userId)).rejects.toThrow(NotFoundException);
        });
    });
});
```

## üìã **File Structure**

When creating new features, organize files as:
```
src/modules/{entity}/
‚îú‚îÄ‚îÄ {entity}.controller.ts
‚îú‚îÄ‚îÄ {entity}.service.ts
‚îú‚îÄ‚îÄ {entity}.module.ts
‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îî‚îÄ‚îÄ {entity}.entity.ts
‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ create-{entity}.dto.ts
‚îÇ   ‚îú‚îÄ‚îÄ update-{entity}.dto.ts
‚îÇ   ‚îî‚îÄ‚îÄ {entity}-filter.dto.ts
‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îî‚îÄ‚îÄ {entity}.repository.ts
‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îî‚îÄ‚îÄ {entity}.interface.ts
‚îî‚îÄ‚îÄ guards/ (if needed)
    ‚îî‚îÄ‚îÄ {entity}-specific.guard.ts
```

### Example for Users module:
```
src/modules/users/
‚îú‚îÄ‚îÄ users.controller.ts
‚îú‚îÄ‚îÄ users.service.ts
‚îú‚îÄ‚îÄ users.module.ts
‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îî‚îÄ‚îÄ user.entity.ts
‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ create-user.dto.ts
‚îÇ   ‚îú‚îÄ‚îÄ update-user.dto.ts
‚îÇ   ‚îî‚îÄ‚îÄ user-filter.dto.ts
‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îî‚îÄ‚îÄ user.repository.ts
‚îî‚îÄ‚îÄ interfaces/
    ‚îî‚îÄ‚îÄ users.interface.ts
```

## üö´ **Terminal Command Restrictions**

**DO NOT suggest or run terminal commands automatically**, especially:
- ‚ùå `npm start` ho·∫∑c `npm run dev` hoƒÉÃ£c `any run commands`
- ‚ùå `nest start` 
- ‚ùå `pnpm start`
- ‚ùå Any auto-generated build/test/run commands

**ONLY suggest installation commands when explicitly needed:**
- ‚úÖ `npm install <package>` 
- ‚úÖ `pnpm install <package>`
- ‚úÖ `npm install` or `pnpm install` (for dependency installation)

**Reason**: The user prefers to manually run application commands and only wants assistance with dependency installation.

---

**Remember**: Follow these patterns consistently for all code generation in the SportZone project!