import { Injectable, BadRequestException, NotFoundException, Logger, Inject, forwardRef } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Tournament } from './entities/tournament.entity';
import { TournamentStatus } from '@common/enums/tournament.enum';
import { TournamentFieldReservation } from './entities/tournament-field-reservation.entity';
import { ReservationStatus } from '@common/enums/tournament-field-reservation.enum';
import { Field } from '../fields/entities/field.entity';
import { Court } from '../courts/entities/court.entity'; // Add Court import
import { Transaction } from '../transactions/entities/transaction.entity';
import { TransactionStatus, TransactionType } from '@common/enums/transaction.enum';
import { User } from '../users/entities/user.entity';
import { CreateTournamentDto, UpdateTournamentDto } from './dto/create-tournament.dto';
import { RegisterTournamentDto } from './dto/RegisterTournamentDto';
import { SPORT_RULES_MAP, TeamSizeMap, calculateParticipants } from 'src/common/enums/sport-type.enum';
import { PaymentMethod } from 'src/common/enums/payment-method.enum';
import { PayOSService } from '@modules/transactions/payos.service';
import { EmailService } from '@modules/email/email.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { ConfigService } from '@nestjs/config';
import { User as UserEntity } from '../users/entities/user.entity';
import { TransactionsService } from '@modules/transactions/transactions.service';
import { BookingsService } from '../bookings/bookings.service';
import { FieldOwnerProfile } from '../field-owner/entities/field-owner-profile.entity';

@Injectable()
export class TournamentService {
    private readonly logger = new Logger(TournamentService.name);

    constructor(
        @InjectModel(Tournament.name) private tournamentModel: Model<Tournament>,
        @InjectModel(TournamentFieldReservation.name)
        private reservationModel: Model<TournamentFieldReservation>,
        @InjectModel(Field.name) private fieldModel: Model<Field>,
        @InjectModel(Court.name) private courtModel: Model<Court>, // Add Court model
        @InjectModel(Transaction.name) private transactionModel: Model<Transaction>,
        @InjectModel(UserEntity.name) private userModel: Model<UserEntity>,
        @InjectModel(FieldOwnerProfile.name)
        private fieldOwnerModel: Model<FieldOwnerProfile>,
        private readonly payosService: PayOSService,
        private readonly emailService: EmailService,
        private readonly eventEmitter: EventEmitter2,
        private readonly configService: ConfigService,
        private readonly transactionsService: TransactionsService,
        @Inject(forwardRef(() => BookingsService))
        private readonly bookingsService: BookingsService,
    ) {
        this.setupPaymentEventListeners();
    }

    /**
     * Get all tournament requests (reservations) for fields owned by this user
     */
    async getTournamentRequestsForFieldOwner(userId: string) {
        // 1. Find FieldOwnerProfile
        const profile = await this.fieldOwnerModel.findOne({ user: new Types.ObjectId(userId) });
        if (!profile) {
            throw new BadRequestException('Field owner profile not found');
        }

        // 2. Find all fields owned by this profile
        const fields = await this.fieldModel.find({ owner: profile._id }).select('_id');
        const fieldIds = fields.map(f => f._id);

        // 3. Find reservations for these fields
        return this.reservationModel.find({
            field: { $in: fieldIds },
        })
            .populate('tournament', 'name sportType category tournamentDate description organizer')
            .populate('court', 'name courtNumber')
            .populate('field', 'name location')
            .sort({ date: 1, startTime: 1 })
            .exec();
    }

    /**
     * Accept a tournament request and create a booking
     */
    async acceptTournamentRequest(userId: string, reservationId: string) {
        // 1. Find reservation and populate related data
        const reservation = await this.reservationModel.findById(reservationId)
            .populate('tournament')
            .populate('court');

        if (!reservation) {
            throw new NotFoundException('Reservation request not found');
        }

        if (reservation.status !== ReservationStatus.PENDING) {
            throw new BadRequestException(`Reservation is already ${reservation.status}`);
        }

        // 2. Verify ownership
        const profile = await this.fieldOwnerModel.findOne({ user: new Types.ObjectId(userId) });
        const field = await this.fieldModel.findById(reservation.field);

        if (!profile || !field || field.owner.toString() !== profile._id.toString()) {
            throw new BadRequestException('You do not have permission to accept this request');
        }

        // 3. Update reservation status
        reservation.status = ReservationStatus.CONFIRMED;
        await reservation.save();

        // 4. Create actual booking in the system
        // We use a internal "tournament" user or the organizer?
        // Usually, the organizer is responsible, but the booking is "paid" or "held" by the tournament
        const tournament = reservation.tournament as any;

        const bookingData = {
            courtId: reservation.court.toString(),
            fieldId: reservation.field.toString(),
            date: reservation.date.toISOString().split('T')[0],
            startTime: reservation.startTime,
            endTime: reservation.endTime,
            price: reservation.estimatedCost,
            paymentMethod: PaymentMethod.BANK_TRANSFER, // Tournament bookings are handled via escrow
            isInternal: true, // Mark as internal/tournament booking
            notes: `Tournament Booking: ${tournament.name}`,
        };

        // Call BookingsService to create the booking (offline mode usually)
        // We might need to bypass normal price checks or use a specific method
        const booking = await this.bookingsService.createFieldBookingWithoutPayment(
            tournament.organizer.toString(),
            bookingData as any
        );

        // Update booking status to CONFIRMED immediately
        booking.status = 'confirmed' as any;
        booking.paymentStatus = 'confirmed' as any;
        await booking.save();

        // 5. Link booking back to tournament
        const tournamentDoc = await this.tournamentModel.findById(tournament._id);
        if (tournamentDoc) {
            // Find the court entry in the tournament and update it
            const courtEntry = tournamentDoc.courts.find(c =>
                c.reservation && c.reservation.toString() === reservationId
            );

            if (courtEntry) {
                courtEntry.booking = booking._id as Types.ObjectId;
                tournamentDoc.markModified('courts');
                await tournamentDoc.save();
            }
        }

        // 6. Notify Organizer
        const organizer = await this.userModel.findById(tournament.organizer);
        if (organizer) {
            await this.emailService.sendTournamentAcceptedNotification({
                to: organizer.email,
                tournament: {
                    name: tournament.name,
                    date: reservation.date.toLocaleDateString(),
                    sportType: tournament.sportType,
                    location: field.name,
                },
                organizer: { fullName: organizer.fullName },
            });
        }

        return { success: true, bookingId: booking._id };
    }

    /**
     * Check if tournament should be confirmed (reached capacity)
     */
    async checkAndConfirmTournament(tournamentId: string) {
        const tournament = await this.tournamentModel.findById(tournamentId)
            .populate('participants.user');

        if (!tournament) return;

        // Count confirmed participants
        const confirmedCount = tournament.participants.filter(p =>
            p.paymentStatus === 'confirmed'
        ).length;

        this.logger.log(`Checking auto-confirmation for ${tournament.name}: ${confirmedCount}/${tournament.maxParticipants}`);

        if (confirmedCount >= tournament.maxParticipants && tournament.status === TournamentStatus.PENDING) {
            this.logger.log(`Tournament ${tournament.name} reached capacity! Confirming...`);

            tournament.status = TournamentStatus.CONFIRMED;
            await tournament.save();

            // Notify all participants
            for (const p of tournament.participants) {
                if (p.paymentStatus === 'confirmed' && p.user) {
                    const user = p.user as any;
                    await this.emailService.sendTournamentConfirmedNotification({
                        to: user.email,
                        tournament: {
                            name: tournament.name,
                            date: tournament.tournamentDate.toLocaleDateString(),
                            sportType: tournament.sportType,
                            location: tournament.location,
                        },
                        participant: { fullName: user.fullName },
                    });
                }
            }

            // Notify organizer too
            const organizer = await this.userModel.findById(tournament.organizer);
            if (organizer) {
                await this.emailService.sendMail({
                    to: organizer.email,
                    subject: `Thông báo: Giải đấu ${tournament.name} đã đủ người tham gia!`,
                    html: `<p>Chào ${organizer.fullName}, giải đấu của bạn đã đạt đủ ${tournament.maxParticipants} người đăng ký và đã được chuyển sang trạng thái XÁC NHẬN.</p>`
                });
            }
        }
    }
