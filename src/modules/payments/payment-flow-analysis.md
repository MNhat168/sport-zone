# Ph√¢n T√≠ch V·∫•n ƒê·ªÅ Payment Flow

## üî¥ V·∫•n ƒê·ªÅ Ch√≠nh

Frontend polling 24 l·∫ßn m√† payment status v·∫´n `pending` sau khi VNPay callback.

## üîç Root Cause Analysis

### 1. **Flow Hi·ªán T·∫°i**

```
User thanh to√°n ‚Üí VNPay redirect v·ªõi params 
‚Üí FE nh·∫≠n returnUrl: /vnpay_return?amount=200000&orderId=6904dd2a6289f3cf36b1dbe3
‚Üí FE polling booking status ‚Üí Status v·∫´n pending
```

### 2. **V·∫•n ƒê·ªÅ ƒê∆∞·ª£c X√°c ƒê·ªãnh**

#### ‚ùå **CRITICAL: VNPay IPN endpoint KH√îNG ƒë∆∞·ª£c g·ªçi**

T·ª´ code `payments.controller.ts`, endpoint `vnpay-ipn` ch·ªâ ƒë∆∞·ª£c k√≠ch ho·∫°t khi:
- VNPay g·ª≠i IPN (Instant Payment Notification) ƒë·∫øn backend
- IPN l√† **server-to-server** callback t·ª´ VNPay

**Nh∆∞ng:**
- returnUrl (`/vnpay_return`) l√† **browser redirect** cho user
- IPN URL ph·∫£i ƒë∆∞·ª£c config ri√™ng trong VNPay dashboard
- N·∫øu IPN URL ch∆∞a ƒë∆∞·ª£c setup ‚Üí VNPay KH√îNG bao gi·ªù g·ªçi endpoint ‚Üí Payment status KH√îNG bao gi·ªù ƒë∆∞·ª£c update

#### ‚ùå **Thi·∫øu Event Listener ƒë·ªÉ update Booking status**

T·ª´ `payments.controller.ts` (line 119-130):
```typescript
// Emit payment success event
this.eventEmitter.emit('payment.success', {
  paymentId: (updated._id as any).toString(),
  bookingId: (updated.booking as any)?.toString?.() || updated.booking,
  ...
});
```

**Nh∆∞ng:**
- Kh√¥ng c√≥ listener n√†o trong `BookingsService` ƒë·ªÉ l·∫Øng nghe event n√†y
- Payment ƒë∆∞·ª£c update nh∆∞ng Booking v·∫´n `pending`

## üéØ Gi·∫£i Ph√°p

### Solution 1: Setup VNPay IPN (RECOMMENDED)

#### A. Config VNPay Dashboard
1. ƒêƒÉng nh·∫≠p VNPay merchant portal
2. V√†o **Settings ‚Üí API Configuration**
3. Set IPN URL: `https://your-domain.com/api/payments/vnpay-ipn`
4. Ensure HTTPS v√† domain accessible t·ª´ VNPay servers

#### B. Th√™m Event Listener trong BookingsService

**File: `bookings.service.ts`**

Th√™m v√†o constructor:
```typescript
@Injectable()
export class BookingsService {
  constructor(
    // ... existing injections
  ) {
    // Listen to payment events
    this.eventEmitter.on('payment.success', this.handlePaymentSuccess.bind(this));
    this.eventEmitter.on('payment.failed', this.handlePaymentFailed.bind(this));
  }

  /**
   * Handle payment success event
   */
  private async handlePaymentSuccess(event: {
    paymentId: string;
    bookingId: string;
    userId: string;
    amount: number;
  }) {
    try {
      this.logger.log(`Processing payment success for booking ${event.bookingId}`);
      
      const booking = await this.bookingModel.findById(event.bookingId);
      if (!booking) {
        this.logger.error(`Booking ${event.bookingId} not found`);
        return;
      }

      // Update booking status to confirmed
      booking.status = BookingStatus.CONFIRMED;
      booking.payment = new Types.ObjectId(event.paymentId);
      await booking.save();

      this.logger.log(`Booking ${event.bookingId} confirmed after payment success`);

      // Optional: Send confirmation email
      await this.emailService.sendBookingConfirmation(booking);
      
    } catch (error) {
      this.logger.error('Error handling payment success', error);
    }
  }

  /**
   * Handle payment failed event
   */
  private async handlePaymentFailed(event: {
    paymentId: string;
    bookingId: string;
    reason: string;
  }) {
    try {
      this.logger.log(`Processing payment failure for booking ${event.bookingId}`);
      
      const booking = await this.bookingModel.findById(event.bookingId);
      if (!booking) {
        this.logger.error(`Booking ${event.bookingId} not found`);
        return;
      }

      // Cancel booking due to payment failure
      booking.status = BookingStatus.CANCELLED;
      booking.cancellationReason = `Payment failed: ${event.reason}`;
      await booking.save();

      // Release schedule slots
      await this.releaseBookingSlots(booking);

      this.logger.log(`Booking ${event.bookingId} cancelled due to payment failure`);
      
    } catch (error) {
      this.logger.error('Error handling payment failure', error);
    }
  }

  /**
   * Release schedule slots when booking is cancelled
   */
  private async releaseBookingSlots(booking: Booking) {
    try {
      const schedule = await this.scheduleModel.findOne({
        field: booking.field,
        date: booking.date
      });

      if (schedule) {
        schedule.bookedSlots = schedule.bookedSlots.filter(slot => 
          !(slot.startTime === booking.startTime && slot.endTime === booking.endTime)
        );
        await schedule.save();
        this.logger.log(`Released slots for booking ${booking._id}`);
      }
    } catch (error) {
      this.logger.error('Error releasing booking slots', error);
    }
  }
}
```

### Solution 2: Alternative - Check Payment in returnUrl

N·∫øu kh√¥ng th·ªÉ setup IPN ngay, t·∫°o endpoint ƒë·ªÉ FE check payment:

**File: `payments.controller.ts`**

```typescript
/**
 * Verify VNPay return and update payment status
 * Called by frontend after redirect from VNPay
 */
@Get('verify-vnpay')
async verifyVNPayReturn(@Query() query: any) {
  const vnp_HashSecret = this.configService.get<string>('vnp_HashSecret');
  if (!vnp_HashSecret) {
    throw new BadRequestException('Payment configuration error');
  }

  const vnp_SecureHash = query.vnp_SecureHash;
  const queryWithoutHash = { ...query };
  delete queryWithoutHash.vnp_SecureHash;
  delete queryWithoutHash.vnp_SecureHashType;

  const sorted = Object.keys(queryWithoutHash)
    .sort()
    .reduce((acc, key) => {
      acc[key] = queryWithoutHash[key];
      return acc;
    }, {} as Record<string, string>);

  const signData = qs.stringify(sorted, { encode: false });
  const hmac = crypto.createHmac('sha512', vnp_HashSecret);
  const signed = hmac.update(Buffer.from(signData, 'utf-8')).digest('hex');

  if (signed !== vnp_SecureHash) {
    throw new BadRequestException('Invalid signature');
  }

  const responseCode: string | undefined = query.vnp_ResponseCode;
  const orderId: string | undefined = query.vnp_TxnRef;
  const transactionId: string | undefined = query.vnp_TransactionNo || query.vnp_BankTranNo;

  if (!orderId) {
    throw new BadRequestException('Missing order ID');
  }

  // Get payment
  let payment = await this.paymentsService.getPaymentById(orderId);
  if (!payment) {
    payment = await this.paymentsService.getPaymentByBookingId(orderId);
  }

  if (!payment) {
    throw new NotFoundException('Payment not found');
  }

  // Update payment status
  if (responseCode === '00') {
    const updated = await this.paymentsService.updatePaymentStatus(
      (payment._id as any).toString(),
      PaymentStatus.SUCCEEDED,
      transactionId,
    );

    // Emit success event
    this.eventEmitter.emit('payment.success', {
      paymentId: (updated._id as any).toString(),
      bookingId: (updated.booking as any)?.toString?.() || updated.booking,
      userId: (updated.paidBy as any)?.toString?.() || updated.paidBy,
      amount: updated.amount,
      method: updated.method,
      transactionId: updated.transactionId,
    });

    return {
      success: true,
      paymentStatus: 'succeeded',
      bookingId: updated.booking,
    };
  } else {
    const updated = await this.paymentsService.updatePaymentStatus(
      (payment._id as any).toString(),
      PaymentStatus.FAILED,
      transactionId,
    );

    // Emit failed event
    this.eventEmitter.emit('payment.failed', {
      paymentId: (updated._id as any).toString(),
      bookingId: (updated.booking as any)?.toString?.() || updated.booking,
      userId: (updated.paidBy as any)?.toString?.() || updated.paidBy,
      amount: updated.amount,
      method: updated.method,
      transactionId: updated.transactionId,
      reason: `VNPay response ${responseCode}`,
    });

    return {
      success: false,
      paymentStatus: 'failed',
      bookingId: updated.booking,
      reason: `VNPay response ${responseCode}`,
    };
  }
}
```

**Frontend s·ª≠ d·ª•ng:**
```typescript
// In vnpay-return-page.tsx
useEffect(() => {
  const verifyPayment = async () => {
    try {
      const queryParams = new URLSearchParams(window.location.search);
      const response = await fetch(`/api/payments/verify-vnpay?${queryParams.toString()}`);
      const data = await response.json();
      
      if (data.success) {
        // Payment verified, start polling for booking confirmation
        setPaymentVerified(true);
      } else {
        setError(data.reason);
      }
    } catch (error) {
      setError('Failed to verify payment');
    }
  };

  verifyPayment();
}, []);
```

## üìã Checklist Tri·ªÉn Khai

### Immediate Actions (Ngay l·∫≠p t·ª©c)

- [ ] **Th√™m event listeners trong BookingsService** (Solution 1B)
- [ ] **T·∫°o endpoint `/payments/verify-vnpay`** (Solution 2)
- [ ] **Test flow v·ªõi VNPay sandbox**

### Setup VNPay IPN (Quan tr·ªçng)

- [ ] **Login VNPay merchant portal**
- [ ] **Configure IPN URL**: `https://your-domain.com/api/payments/vnpay-ipn`
- [ ] **Test IPN v·ªõi VNPay sandbox**
- [ ] **Verify IPN ƒë∆∞·ª£c g·ªçi th√†nh c√¥ng**

### Code Changes Required

#### 1. `bookings.service.ts`
```typescript
// Add event listeners in constructor
// Add handlePaymentSuccess method
// Add handlePaymentFailed method
// Add releaseBookingSlots method
```

#### 2. `payments.controller.ts`
```typescript
// Add verifyVNPayReturn endpoint
```

#### 3. Environment Variables
```bash
# Ensure these are set
VNP_TMN_CODE=your_tmn_code
VNP_HASH_SECRET=your_hash_secret
VNP_URL=https://sandbox.vnpayment.vn/paymentv2/vpcpay.html
VNP_RETURN_URL=https://your-domain.com/vnpay-return
# New: IPN endpoint will be auto-discovered by VNPay
```

## üß™ Testing

### Test Case 1: Successful Payment
1. Create booking ‚Üí Get payment URL
2. Complete payment in VNPay sandbox
3. Verify IPN ƒë∆∞·ª£c g·ªçi (check logs)
4. Verify booking status = `confirmed`
5. Verify payment status = `succeeded`

### Test Case 2: Failed Payment
1. Create booking ‚Üí Get payment URL
2. Cancel payment in VNPay
3. Verify IPN ƒë∆∞·ª£c g·ªçi
4. Verify booking status = `cancelled`
5. Verify payment status = `failed`
6. Verify schedule slots ƒë∆∞·ª£c release

### Test Case 3: Duplicate IPN
1. Complete payment
2. Manually trigger IPN again
3. Verify idempotency (kh√¥ng t·∫°o duplicate updates)

## üéØ Expected Results

After implementing solutions:

1. ‚úÖ VNPay IPN ƒë∆∞·ª£c g·ªçi th√†nh c√¥ng
2. ‚úÖ Payment status ƒë∆∞·ª£c update ngay l·∫≠p t·ª©c
3. ‚úÖ Booking status ƒë∆∞·ª£c update t·ª´ `pending` ‚Üí `confirmed`
4. ‚úÖ Frontend kh√¥ng c·∫ßn polling 24 l·∫ßn
5. ‚úÖ User experience m∆∞·ª£t m√† h∆°n

## üìö References

- [VNPay API Documentation](https://sandbox.vnpayment.vn/apis/docs/)
- [NestJS Event Emitter](https://docs.nestjs.com/techniques/events)
- [Payment Gateway Best Practices](https://stripe.com/docs/payments/payment-intents)
